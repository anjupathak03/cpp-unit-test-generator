import { fsx } from './utils/fsx.js';
import { buildPrompt } from './prompt/builder.js';
import { fetch as llmFetch } from './llm/client.js';
import { findTestFile } from './utils/findTestFile.js';
import { applyAndValidateTests } from './utils/applyAndValidateTests.js';
import { applyAndValidateTestsWithFixing } from './utils/testFixer.js';
import { replaceWithTestExtension } from './utils/fileExtensions.js';
import chalk from 'chalk';

export interface Cfg {
  srcFile: string;
  testFile: string;
  root: string;
  bypassValidation?: boolean;
  enableAutoFix?: boolean;
  maxFixAttempts?: number;
  gpp?: boolean; // Use g++ single file mode
}

export async function run(cfg: Cfg, signal: AbortSignal) {
  console.log(chalk.blue('ðŸ“– Reading source and test files...'));
  const srcOrig = await fsx.read(cfg.srcFile);
  console.log(chalk.green(`âœ… Source file read: ${cfg.srcFile}`));
  
  const testOrig = await fsx.readIfExists(cfg.testFile);
  if (testOrig) {
    console.log(chalk.green(`âœ… Existing test file found: ${cfg.testFile}`));
  } else {
    console.log(chalk.yellow(`âš ï¸  No existing test file at: ${cfg.testFile}`));
  }

  let testPath = cfg.testFile;
  if (!testPath || !fsx.exists(testPath)) {
    console.log(chalk.blue('ðŸ” Searching for existing test file...'));
    testPath = await findTestFile(cfg.srcFile, cfg.root)
            ?? replaceWithTestExtension(cfg.srcFile);  // last resort
    console.log(chalk.gray(`ðŸ“ Using test file: ${testPath}`));
  }

  const testOrigContent = await fsx.readIfExists(testPath);

  console.log(chalk.blue('ðŸ”¨ Building prompt for LLM...'));
  const prompt = buildPrompt({
    srcPath     : cfg.srcFile,
    srcText     : srcOrig,
    testText    : testOrigContent
  });
  console.log(chalk.green('âœ… Prompt built successfully'));

  console.log(chalk.blue('ðŸ¤– Sending request to LLM...'));
  const reply = await llmFetch(prompt, signal);
  console.log(chalk.green('âœ… LLM response received'));

  console.log(chalk.blue('ðŸ“Š Processing LLM response...'));
  if (!reply.tests?.length) {
    console.log(chalk.yellow('âš ï¸  No tests generated by LLM'));
    return;
  }
  
  console.log(chalk.green(`âœ… Generated ${reply.tests.length} test(s)`));
  reply.tests.forEach((test, index) => {
    console.log(chalk.gray(`  ${index + 1}. ${test.name}`));
  });

  console.log(chalk.blue('ðŸ”§ Applying and validating tests...'));
  
  // Use the enhanced version with auto-fixing if enabled
  const useAutoFix = cfg.enableAutoFix ?? true;
  const maxFixAttempts = cfg.maxFixAttempts ?? 3;
  
  const results = useAutoFix 
    ? await applyAndValidateTestsWithFixing({
        testFile: testPath,
        newTests: reply.tests,
        cfg: { ...cfg, testFile: testPath },
        signal,
        bypassValidation: cfg.bypassValidation ?? true,
        enableAutoFix: useAutoFix,
        maxFixAttempts
      })
    : await applyAndValidateTests({
        testFile: testPath,
        newTests: reply.tests,
        cfg: { ...cfg, testFile: testPath },
        signal,
        bypassValidation: cfg.bypassValidation ?? true
      });

  console.log(chalk.blue('ðŸ“‹ Test Results:'));
  // Log results for each test
  for (const r of results) {
    if (r.verdict === 'pass') {
      const fixedIndicator = (r as any).fixed ? ' (auto-fixed)' : '';
      console.log(chalk.green(`  âœ… ${r.name}${fixedIndicator}`));
    } else {
      console.log(chalk.red(`  âŒ ${r.name}`));
    }
  }

  const passedCount = results.filter(r => r.verdict === 'pass').length;
  const totalCount = results.length;
  
  console.log(chalk.blue('â”€'.repeat(50)));
  if (passedCount === totalCount) {
    console.log(chalk.green(`ðŸŽ‰ All ${totalCount} tests passed successfully!`));
  } else {
    console.log(chalk.yellow(`ðŸ“Š Results: ${passedCount}/${totalCount} tests passed`));
  }
  console.log(chalk.blue('Test generation completed'));
  return results;
}
